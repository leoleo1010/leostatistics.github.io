<!-- Javascript progressive tutorial by example for students, by Tom Gastaldi, University of Rome "Sapienza",
tommaso.gastaldi@gmail.com, WhatsApp: 3272347610. Please report corrections, improvements, reference links, etc.-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <script src="Rettangolo.js"></script>
  <title>Simple demo on how to move or resize a rectangular area for charts</title>
  <style>
    body * {
      font-family: arial, sans-serif;
      font-size: 14px;
    }

    textarea {
      border: none;
      outline: none;
      height: 500px;
      width: 200px;
      white-space: nowrap; /* disable word wrap */
      background-color: whitesmoke;
      margin-right: 5px;
      font-size: 11px;
      font-family: Inconsolata, monospace
    }

    canvas {
      width: 800px;
      height: 500px;
      background-color: black;
      border: 1px solid blue;
      vertical-align: top;
    }
  </style>
</head>
<body>

<p id="labelDateTime"></p>
<hr>
<label for="textAreaInfo"></label>
<textarea id="textAreaInfo"></textarea>
<h3>Euler-Maruyama simulator for stochastic differential equation (SDE)</h3>

<label for="processSelect">Select a Stochastic Process:</label>
    <select id="processSelect" class="form-control">
        <option value="geometricBrownianMotion">Geometric Brownian Motion</option>
        <option value="arithmeticBrownianMotion">Arithmetic Brownian Motion</option>
        <option value="ornsteinUhlenbeck">Ornstein Uhlenbeck (mean-reverting)</option>
        <option value="vasicek">Vasicek</option>
        <option value="coxIngellRoss">Cox-Ingell-Ross</option>
        <!-- Add more options for other stochastic processes -->
    </select>

 <label for="mu">Coefficiente di ritorno al valore medio (\( \theta \)): </label>
<input type="number" step="0.01" id="theta" value="0.1"><br>

<label for="mu">Drift (\( \mu \)): </label>
<input type="number" step="0.01" id="mu" value="0.1"><br>

<label for="sigma">Diffusion (\( \sigma \)): </label>
<input type="number" step="0.01" id="sigma" value="0.2"><br>

<label for="dt">Time Step (\( \Delta t \)): </label>
<input type="number" step="0.01" id="dt" value="0.01"><br>

<label for="totalTime">Total Time: </label>
<input type="number" step="1" id="totalTime" value="100"><br>

<label for="numPaths">Number of Machines: </label>
<input type="number" step="1" id="numPaths" value="3"><br>


<button onclick="exploreStochasticProcess()">Simulate</button>

<button onclick="clearCanvas()">Clear Canvas</button>
<canvas id="myCanvas" width="800" height="500" oncontextmenu="return false"></canvas>

<script>

    "use strict";

    const textAreaInfo = document.getElementById("textAreaInfo");
    const myCanvas = document.getElementById("myCanvas");
    const ctx = myCanvas.getContext("2d");
    const rettangolo = new Rettangolo(30, 30, 400, 300);

    let x_RectDown = 0;
    let y_RectDown = 0;
    let width_RectDown = rettangolo.width;
    let height_RectDown = rettangolo.height;

    let x_MouseDown = 0;
    let y_MouseDown = 0;
    let x_MouseMove = 0;
    let y_MouseMove = 0;
    let x_MouseUp = 0, y_MouseUp = 0;

    let draggingStarted = false;
    let resizingStarted = false;

    let dx_ContinueDrag = 0;
    let dy_ContinueDrag = 0;
    let x_Mouse_Old = 0;
    let y_Mouse_Old = 0;
    let speed_dt = 30;   // milliseconds to poll mouse speed
    let speed_dx = 0;
    let speed_dy = 0;

    myCanvas.addEventListener("mousedown", mousedown_Handler);   //myCanvas.onmousedown = (e) => mousedown_Handler(e);
    myCanvas.addEventListener("mousemove", mousemove_Handler);   //myCanvas.onmousemove = (e) => mousemove_Handler(e);
    myCanvas.addEventListener("mouseup", mouseup_Handler);       //myCanvas.onmouseup = (e) => mouseup_Handler(e);
    myCanvas.addEventListener("wheel", wheel_Handler);           //myCanvas.onwheel = (e) => wheel_Handler(e);

    //misura velocità mouse
    setInterval(mouseVelocityMonitor, speed_dt);

    //disegno rettangolo
    setInterval(disegnaScena, 20);

    //rientra ogni tanto per misurare velocita istantanea
    function mouseVelocityMonitor() {

        speed_dx = x_MouseMove - x_Mouse_Old;
        speed_dy = y_MouseMove - y_Mouse_Old;
        x_Mouse_Old = x_MouseMove;
        y_Mouse_Old = y_MouseMove;

        //Some info

        const rect = myCanvas.getBoundingClientRect();

        const userInfo = [];
        userInfo.push("Mouse Down: X=" + x_MouseDown + ", Y=" + y_MouseDown);
        userInfo.push("Mouse Move: X=" + x_MouseMove + ", Y=" + y_MouseMove);
        userInfo.push("Mouse Up:   X=" + x_MouseUp + ", Y=" + y_MouseUp);
        userInfo.push("Rect Down:  X=" + x_RectDown + ", Y=" + y_RectDown);
        userInfo.push("Rect X=" + rettangolo.x + ", Y=" + rettangolo.y);
        userInfo.push("Rect W=" + rettangolo.width + ", H=" + rettangolo.height);
        userInfo.push("Rect L=" + rettangolo.left() + ", R=" + rettangolo.right());
        userInfo.push("Rect T=" + rettangolo.top() + ", B=" + rettangolo.bottom());
        userInfo.push("Rect AR = " + rettangolo.aspectRatio().toFixed(2));
        userInfo.push("Rect Contains mouse = " + !!rettangolo.contains(x_MouseMove - rect.x, y_MouseMove - rect.y));
        userInfo.push("dx: " + speed_dx + " dy: " + speed_dy + " dt: " + speed_dt);
        userInfo.push("vel dx: " + (1000 * speed_dx / speed_dt).toFixed(1)
            + " dy: " + (1000 * speed_dy / speed_dt).toFixed(1) + " px/s");

        textAreaInfo.innerHTML = userInfo.join("\n");

    }

    function mousedown_Handler(e) {

        x_MouseDown = e.x;
        y_MouseDown = e.y;
        x_RectDown = rettangolo.x;
        y_RectDown = rettangolo.y;
        width_RectDown = rettangolo.width;
        height_RectDown = rettangolo.height;

        const rect = myCanvas.getBoundingClientRect();
        if (!rettangolo.contains(e.x - rect.x, e.y - rect.y)) {
            return
        }

        if (e.which === 1)            //left button
        {
            draggingStarted = true;

        } else if (e.which === 3)     //right button
        {
            resizingStarted = true
        }
    }

    function mousemove_Handler(e) {
        x_MouseMove = e.x;
        y_MouseMove = e.y;

        const delta_X = x_MouseMove - x_MouseDown;
        const delta_Y = y_MouseMove - y_MouseDown;

        if (draggingStarted) {
            rettangolo.x = x_RectDown + delta_X;
            rettangolo.y = y_RectDown + delta_Y;
        } else if (resizingStarted) {
            rettangolo.width = width_RectDown + delta_X;
            rettangolo.height = height_RectDown + delta_Y;
        }
    }

    function mouseup_Handler(e) {

        x_MouseUp = e.x;
        y_MouseUp = e.y;

        resizingStarted = false;

        if (draggingStarted) {

            draggingStarted = false;

            //continue drag effect
            dx_ContinueDrag = speed_dx;
            dy_ContinueDrag = speed_dy;

            continuaDrag();
        }
    }

    //effetto di inerzia drag
    function continuaDrag() {

        if (Math.max(Math.abs(dx_ContinueDrag), Math.abs(dy_ContinueDrag)) < 1 ||
            draggingStarted || resizingStarted) {
            return
        }
        rettangolo.x += Math.round(dx_ContinueDrag);
        rettangolo.y += Math.round(dy_ContinueDrag);
        dx_ContinueDrag *= 0.6;
        dy_ContinueDrag *= 0.6;
        setTimeout(continuaDrag, speed_dt);   //rientro fino a che finisce lo slancio

    }

    function wheel_Handler(e) {

        //const rect = myCanvas.getBoundingClientRect();

        // if (!rettangolo.contains(e.x - rect.x, e.y - rect.y)) {
        //     return
        // }

        const shiftY = 15 * Math.sign(e.deltaY);
        const shiftX = Math.round(shiftY * rettangolo.aspectRatio());     //keep aspect ratio

        rettangolo.y -= shiftY;
        rettangolo.x -= shiftX;
        rettangolo.width += shiftX + shiftX;
        rettangolo.height += shiftY + shiftY;

    }

    function disegnaScena() {

        //stampa data
        document.getElementById("labelDateTime").innerHTML = new Date().toLocaleTimeString();


        //clear myCanvas
        ctx.clearRect(0, 0, myCanvas.width, myCanvas.height);

        //contenitore chart
        rettangolo.disegnaRettangolo(ctx, "gray", 2, [1, 1]);

        exploreStochasticProcess();

    }


    //References

    //https://www.geeksforgeeks.org/difference-between-var-and-let-in-javascript/
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness
    //https://developer.mozilla.org/en-US/docs/Web/API/myCanvasRenderingContext2D/setLineDash

</script>

<script>
       
    // exploreStochasticProcess(): FUNZIONE che si occupa di fare lo switch per ogni SDE
    function exploreStochasticProcess() {
        const processSelect = document.getElementById('processSelect');
        const simulateBtn = document.getElementById('simulateBtn');

        const canvas = document.getElementById('myCanvas');
        const context = canvas.getContext('2d');

        const selectedProcess = processSelect.value;

        // clear the canvas
        clearCanvas();

        // Simulate and display the selected stochastic process
        switch (selectedProcess) {
            case 'geometricBrownianMotion':
                simulateGeometricBrownianMotion();
              //  const theoryGBM = document.getElementById('theoryGBM');
              // if(theoryGBM.style.display === "none"){
                   // theoryGBM.style.display = "block";
              //  } 
                break;
            case 'arithmeticBrownianMotion':
                simulateArithmeticBrownianMotion();
                break;
            case 'ornsteinUhlenbeck':
                simulateOrnsteinUhlenbeck();
                break;
            // Add cases for other stochastic processes
            case 'vasicek':
                simulateVasicek();
                break;
            // Add cases for other stochastic processe
            case 'coxIngellRoss':
                simulateCoxIngellRoss();
                break;
            // Add cases for other stochastic processe
            default:
                // Handle invalid selection
                break;
        }
    }

    function standardNormalDistribution() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random(); // Converting [0,1) to (0,1)
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function simulateGeometricBrownianMotion() {
        const mu = parseFloat(document.getElementById('mu').value);
        const sigma = parseFloat(document.getElementById('sigma').value);
        const dt = parseFloat(document.getElementById('dt').value);
        const totalTime = parseFloat(document.getElementById('totalTime').value);
        const numPaths = parseInt(document.getElementById('numPaths').value);
    
        const canvas = document.getElementById('myCanvas');
        const context = canvas.getContext('2d');
    
        const scaleX = canvas.width / totalTime;
        const scaleY = canvas.height / 10; // Adjust as needed
    
        context.clearRect(0, 0, canvas.width, canvas.height);
    
        for (let pathIndex = 0; pathIndex < numPaths; pathIndex++) {
            let currentValue = 1; // Start from an initial value of 1
    
            context.beginPath();
            context.moveTo(0, canvas.height / 2);
    
            for (let t = 0; t <= totalTime; t += dt) {
                const randomValue = standardNormalDistribution();
                currentValue = currentValue * Math.exp((mu - (sigma ** 2) / 2) * dt + sigma * Math.sqrt(dt) * randomValue);
    
                const x = t * scaleX;
                const y = canvas.height / 2 - currentValue * scaleY;
    
                context.lineTo(x, y);
            }
    
            // Set a random color for each path
            context.strokeStyle = getRandomColor();
            context.stroke();
        }
    }
    

    function simulateArithmeticBrownianMotion () {

        const mu = parseFloat(document.getElementById('mu').value);
        const sigma = parseFloat(document.getElementById('sigma').value);
        const dt = parseFloat(document.getElementById('dt').value);
        const totalTime = parseFloat(document.getElementById('totalTime').value);
        const numPaths = parseInt(document.getElementById('numPaths').value);

        const canvas = document.getElementById('myCanvas');
        const context = canvas.getContext('2d');


        const scaleX = canvas.width / totalTime;
        const scaleY = canvas.height / 10; // Adjust as needed

        context.clearRect(0, 0, canvas.width, canvas.height);

        for (let pathIndex = 0; pathIndex < numPaths; pathIndex++) {
            let currentValue = 0;

            context.beginPath();
            context.moveTo(0, canvas.height / 2);

            for (let t = 0; t <= totalTime; t += dt) {
                const randomValue = standardNormalDistribution();
                currentValue = currentValue + mu * dt + sigma * Math.sqrt(dt) * randomValue;

                const x = t * scaleX;
                const y = canvas.height / 2 - currentValue * scaleY;

                context.lineTo(x, y);
            }

            // Set a random color for each path
            context.strokeStyle = getRandomColor();
            context.stroke();
        }
    }

    function simulateOrnsteinUhlenbeck (){
         // Parametri del processo di Ornstein-Uhlenbeck
        const theta = parseFloat(document.getElementById('theta').value);
        const mu = parseFloat(document.getElementById('mu').value); //ok
        const sigma = parseFloat(document.getElementById('sigma').value);//ok

        // Numero di percorsi da simulare
        const numPaths = parseInt(document.getElementById('numPaths').value);// ok

        // Intervallo di tempo e numero di passi
        const dt = parseFloat(document.getElementById('dt').value); //ok
        const totalTime = parseFloat(document.getElementById('totalTime').value);

       // !!! const numSteps = parseInt(document.getElementById('numSteps').value); // NO SAREBBE: totalTime !!!

        const canvas = document.getElementById('myCanvas');
        const context = canvas.getContext('2d');


        context.clearRect(0, 0, canvas.width, canvas.height);

        for (let path = 0; path < numPaths; path++) {
            // Inizializzazione del valore iniziale per ogni percorso
            let x = 0.0;

            // Generazione di un colore casuale per ogni percorso
            const color = getRandomColor();

            context.beginPath();
            context.strokeStyle = color;
            context.lineWidth = 1;

            for (let t = 0; t < totalTime; t += dt) {
            // Calcolo dell'incremento stocastico
            const dW = sigma * Math.sqrt(dt) * (2 * Math.random() - 1);

            // Risoluzione dell'equazione differenziale stocastica
            x += theta * (mu - x) * dt + dW;

            // Disegno della linea tra i punti successivi
            const xPos = t * (canvas.width / totalTime);
            const yPos = canvas.height - x * (canvas.height / (2 * mu)) + path * 20;
            
            if (t === 0) {
                context.moveTo(xPos, yPos);
            } else {
                context.lineTo(xPos, yPos);
            }
            }

            context.stroke();
            context.closePath();
        }
    }

    function simulateVasicek() {
        // FORMULA DI VASICEK: drt=a(b−rt)dt+σdWt
        const a = parseFloat(document.getElementById('theta').value); 
        const b = parseFloat(document.getElementById('mu').value);
        const sigma = parseFloat(document.getElementById('sigma').value);
        const dt = parseFloat(document.getElementById('dt').value);
        const totalTime = parseFloat(document.getElementById('totalTime').value);
        const numPaths = parseInt(document.getElementById('numPaths').value);
        
        const canvas = document.getElementById('myCanvas');
        const context = canvas.getContext('2d');
    
        const scaleX = canvas.width / totalTime;
        const scaleY = canvas.height / 10; // Adjust as needed
    
        context.clearRect(0, 0, canvas.width, canvas.height);
    
        for (let pathIndex = 0; pathIndex < numPaths; pathIndex++) {
            let currentValue = 0;
    
            context.beginPath();
            context.moveTo(0, canvas.height / 2);
    
            for (let t = 0; t <= totalTime; t += dt) {
                const randomValue = standardNormalDistribution();
                currentValue = currentValue + a * (b - currentValue) * dt + sigma * Math.sqrt(dt) * randomValue;
    
                const x = t * scaleX;
                const y = canvas.height / 2 - currentValue * scaleY;
    
                context.lineTo(x, y);
            }
    
            // Set a random color for each path
            context.strokeStyle = getRandomColor();
            context.stroke();
        }
    }

    function simulateCoxIngellRoss() {
        // Parametri del processo di Cox-Ingersoll-Ross
        const a = parseFloat(document.getElementById('theta').value);
        const b = parseFloat(document.getElementById('mu').value);
        const sigma = parseFloat(document.getElementById('sigma').value);
        const dt = parseFloat(document.getElementById('dt').value);
        const totalTime = parseFloat(document.getElementById('totalTime').value);
        const numPaths = parseInt(document.getElementById('numPaths').value);
    
        const canvas = document.getElementById('myCanvas');
        const context = canvas.getContext('2d');
    
        const scaleX = canvas.width / totalTime;
        const scaleY = canvas.height / 10; // Adjust as needed
    
        context.clearRect(0, 0, canvas.width, canvas.height);
    
        for (let pathIndex = 0; pathIndex < numPaths; pathIndex++) {
            let currentValue = 0;
    
            context.beginPath();
            context.moveTo(0, canvas.height / 2);
    
            for (let t = 0; t <= totalTime; t += dt) {
                const randomValue = standardNormalDistribution();
                currentValue = currentValue + a * (b - currentValue) * dt + sigma * Math.sqrt(currentValue) * randomValue;
    
                const x = t * scaleX;
                const y = canvas.height / 2 - currentValue * scaleY;
    
                context.lineTo(x, y);
            }
    
            // Set a random color for each path
            context.strokeStyle = getRandomColor();
            context.stroke();
        }
    }
    
    

    // UTILITY Function to generate a random color
    function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    
    // UTILITY Function to clear the canvas
    function clearCanvas() {
        const canvas = document.getElementById('myCanvas');
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

</script>



</body>
</html>
